package com.algorithm.disce.bduo;

public class Two190 {

    public int reverseBits(int n) {
        //分治合并策略
        //1.首先随便找一个数 (为了看的清楚用_作分隔，可以忽略)
        //例：十进制43261596;   // 0000 ‭0010 1001 0100 _ 0001 1110 1001 1100‬

        //2.左边16位移到右边，右边16位移到左边，然后使用|符号合并起来

        //3.Java中的无符号位移 >>>：无论是正数还是负数，高位通通补0。
        //>>：带符号右移。正数右移高位补0，负数右移高位补1。
        //|：按位或逻辑，该位只要有一位为1，结果就为1，这里用来合并
        //使用一些有规律的数，将16位，再分成左右8位进行反转后合并

        //4.重复以上步骤，分组、合并，最后得到反转后的结果。

        //5.总结来说就是利用位运算进行反转，同时存储反转后的数，继续分治进行反转，直到全部反转完成

        //特殊的数值
        //0xff00ff00 表示16进制数1111 1111 0000 0000 _ 1111 1111 0000 0000 ，
        //0x00ff00ff 表示16进制数0000 0000 1111 1111 _ 0000 0000 1111 1111，

//        n = (n >>> 16) | (n << 16);
        //n & 0xff00ff00 可以将 n的前16位和后16位的后8位清零
        //n & 0x00ff00ff 可以将 n的前16位和后16位的前8位清零
//        n = ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8);
//        n = ((n & 0xf0f0f0f0) >>> 4) | ((n & 0x0f0f0f0f) << 4);
//        n = ((n & 0xcccccccc) >>> 2) | ((n & 0x33333333) << 2);
//        n = ((n & 0xaaaaaaaa) >>> 1) | ((n & 0x55555555) << 1);
//        return n;
        int r = 0;
        int power = 31;
        while (n != 0) {
            r += ((n & 1) << power);
            //无符号位移 >>>：无论是正数还是负数，高位通通补0
            //需要使用 >>>, java最左位为符号位，若用 >> , 在n为负数情况下，符号位一直会是1
            n >>>= 1;
            power -= 1;
        }
        return r;
    }


}
